{"version":3,"file":"lists-CFI8KVHO.js","sources":["../lib/codemirror-kit/decorations.ts","../src/editor/extensions/lists.ts"],"sourcesContent":["import { syntaxTree } from '@codemirror/language'\nimport { type EditorState, type Range, type RangeCursor, RangeSet, StateField, type Transaction } from '@codemirror/state'\nimport { Decoration, EditorView, type WidgetType } from '@codemirror/view'\nimport { type SyntaxNodeRef } from '@lezer/common'\n\n// Todo: Maybe open a PR to expose these types.\n// https://github.com/codemirror/view/blob/3f1b991f3db20d152045ae9e6872466fc8d8fdac/src/decoration.ts\nexport type LineDecorationSpec = { attributes?: { [key: string]: string }, class?: string, [other: string]: any }\nexport type MarkDecorationSpec = { attributes?: { [key: string]: string }, class?: string, inclusive?: boolean, inclusiveEnd?: boolean, inclusiveStart?: boolean, tagName?: string, [other: string]: any }\nexport type ReplaceDecorationSpec = { block?: boolean, inclusive?: boolean, inclusiveEnd?: boolean, inclusiveStart?: boolean, widget?: WidgetType, [other: string]: any }\nexport type WidgetDecorationSpec = { widget: WidgetType, block?: boolean, side?: number, [other: string]: any }\n\nexport type Defined<T> = Required<{\n  [K in keyof T]: NonNullable<T[K]>\n}>\n\n// Custom types.\nexport type CustomDecorationArgs = Parameters<typeof Decoration.mark>[0]\nexport type CustomDecoration<T> = T & Decoration\nexport type CustomDecorationTypes = 'line' | 'mark' | 'replace' | 'widget'\nexport type CustomWidget<T> = T & WidgetSpec\nexport type CustomWidgetArgs<T extends PartialWidgetSpec> = {\n  [K in keyof T]?: K extends 'eq' ? (other: CustomWidget<Defined<T>>) => boolean : T[K]\n}\nexport type CustomWidgetOptions<T extends PartialWidgetSpec> = {\n  [K in keyof T]: K extends 'compare' | 'eq' ? (other: CustomWidget<Defined<T>>) => boolean : T[K]\n}\nexport type CustomWidgetDecoration<T> = T & WidgetDecoration<T> & Decoration\nexport type CustomWidgetDecorationArgs = WidgetDecorationSpec & Record<string, any>\nexport type NodeBlockDecoration<T> = CustomWidgetDecoration<T> & { widget: { node: SyntaxNodeRef } }\nexport type NodeDecoratorArgs<T extends Decoration> = {\n  nodes: string[],\n  onMatch: (state: EditorState, node: SyntaxNodeRef) => T | T[] | void,\n  optimize?: boolean,\n  range?: {\n    from?: number,\n    to?: number,\n  },\n}\nexport type PartialWidgetSpec = Partial<WidgetSpec>\nexport type TypedDecoration = Decoration & { spec: Decoration['spec'] & { type: CustomDecorationTypes } }\nexport type WidgetSpec = WidgetType & { id?: string }\nexport type WidgetDecoration<T> = { block: boolean, side: number, widget: CustomWidget<T> }\n\nexport const buildBlockWidgetDecoration = <T extends CustomWidgetDecorationArgs>(options: T) => {\n  return buildWidgetDecoration({\n    block: true,\n    side: -1,\n    ...options,\n  })\n}\n\nexport const buildLineDecoration = <T extends MarkDecorationSpec>(options: T) => {\n  return Decoration.line({\n    ...options,\n    type: 'line',\n  }) as CustomDecoration<T>\n}\n\nexport const buildMarkDecoration = <T extends MarkDecorationSpec>(options: T) => {\n  return Decoration.mark({\n    ...options,\n    type: 'mark',\n  }) as CustomDecoration<T>\n}\n\nexport type WidgetOptions<T extends Record<string, any>> = {\n  [K in ((keyof T) | 'compare' | 'eq')]?: K extends 'compare' | 'eq' ? (other: WidgetReturn<T>) => boolean\n    : K extends keyof WidgetSpec ? WidgetSpec[K]\n    : T[K]\n}\nexport type WidgetReturn<T extends Record<string, any>> = {\n  [K in keyof (T & WidgetSpec)]: K extends keyof T ? NonNullable<T[K]>\n    : K extends keyof WidgetSpec ? WidgetSpec[K]\n    : never\n}\n\nexport const buildWidget = <T extends Record<string, any>>(options: WidgetOptions<T>): WidgetSpec => {\n  const eq = (other: WidgetReturn<T>) => {\n    if (options.eq) return options.eq(other)\n    if (!options.id) return false\n\n    return options.id === other.id\n  }\n\n  return {\n    compare: (other: WidgetReturn<T>) => {\n      return eq(other)\n    },\n    coordsAt: () => null,\n    destroy: () => {},\n    eq: (other: WidgetReturn<T>) => {\n      return eq(other)\n    },\n    estimatedHeight: -1,\n    ignoreEvent: () => true,\n    lineBreaks: 0,\n    toDOM: () => {\n      return document.createElement('span')\n    },\n    updateDOM: () => false,\n    ...options,\n  }\n}\n\nexport const buildWidgetDecoration = <T extends CustomWidgetDecorationArgs>(options: T): CustomWidgetDecoration<T> => {\n  return Decoration.widget({\n    block: false,\n    side: 0,\n    ...options,\n    widget: buildWidget({\n      ...options.widget,\n    }),\n    type: 'widget',\n  }) as CustomWidgetDecoration<T>\n}\n\nexport const buildNodeDecorations = <T extends TypedDecoration>(state: EditorState, options: NodeDecoratorArgs<T>) => {\n  const decorationRanges: Range<NodeBlockDecoration<T>>[] = []\n\n  syntaxTree(state).iterate({\n    enter: (node) => {\n      if (options.nodes.includes(node.type.name)) {\n        const maybeDecorations = options.onMatch(state, node)\n\n        if (!maybeDecorations) return\n\n        const decorations = Array<T>().concat(maybeDecorations)\n\n        decorations.forEach((decoration) => {\n          if (decoration.spec.type === 'line') {\n            const wrapped = buildLineDecoration({ ...decoration.spec, node: { ...node } })\n\n            for (let line = state.doc.lineAt(node.from); line.from < node.to; line = state.doc.lineAt(line.to + 1)) {\n              decorationRanges.push(wrapped.range(line.from))\n\n              if (line.to === state.doc.length) break\n            }\n          }\n\n          if (decoration.spec.type === 'mark') {\n            const wrapped = buildMarkDecoration({ ...decoration.spec, node: { ...node } }).range(node.from, node.to)\n\n            decorationRanges.push(wrapped)\n          }\n\n          if (decoration.spec.type === 'widget') {\n            const wrapped = buildWidgetDecoration({ ...decoration.spec, node: { ...node } }).range(node.from)\n\n            decorationRanges.push(wrapped)\n          }\n        })\n      }\n    },\n    from: options.range?.from,\n    to: options.range?.to,\n  })\n\n  return decorationRanges.sort((left, right) => {\n    return left.from - right.from\n  })\n}\n\nexport const buildOptimizedNodeDecorations = <T extends Decoration>(rangeSet: RangeSet<NodeBlockDecoration<T>>, transaction: Transaction, options: NodeDecoratorArgs<T>) => {\n  const decorations = [] as Range<NodeBlockDecoration<T>>[]\n  const cursor = rangeSet.iter()\n  const cursors = [] as RangeCursor<NodeBlockDecoration<T>>[]\n  const cursorsToSkip = [] as RangeCursor<NodeBlockDecoration<T>>[]\n\n  while (cursor.value) {\n    cursors.push({ ...cursor })\n    cursor.next()\n  }\n\n  transaction.changes.iterChangedRanges((_beforeFrom, _beforeTo, changeFrom, changeTo) => {\n    cursors.forEach((cursor) => {\n      if (cursor.value) {\n        const nodeLength = cursor.value.spec.node.to - cursor.value.spec.node.from\n        const cursorFrom = cursor.from\n        const cursorTo = cursor.from + nodeLength\n\n        if (isOverlapping(cursorFrom, cursorTo, changeFrom, changeTo)) {\n          cursorsToSkip.push(cursor)\n        }\n      }\n    })\n\n    const range = { from: changeFrom, to: changeTo }\n\n    decorations.push(...buildNodeDecorations(transaction.state, { ...options, range }))\n  })\n\n  const cursorDecos = cursors.filter(cursor => !cursorsToSkip.includes(cursor)).flatMap((cursor) => {\n    const range = cursor.value?.range(cursor.from) as Range<NodeBlockDecoration<T>>\n\n    if (!range) return []\n\n    return [range]\n  })\n\n  decorations.push(...cursorDecos)\n\n  const allDecorations = decorations.sort((left, right) => {\n    return left.from - right.from\n  })\n\n  // This reprocesses the entire state.\n  return allDecorations\n}\n\nexport const isOverlapping = (x1: number, x2: number, y1: number, y2: number) => {\n  return Math.max(x1, y1) <= Math.min(x2, y2)\n}\n\nexport const nodeDecorator = <T extends Decoration>(options: NodeDecoratorArgs<T>) => {\n  return StateField.define<RangeSet<NodeBlockDecoration<T>>>({\n    create(state) {\n      return RangeSet.of(buildNodeDecorations(state, options))\n    },\n    update(rangeSet, transaction) {\n      // Reconfiguration and state effects will reprocess the entire state to ensure nothing is missed.\n      if (transaction.reconfigured || transaction.effects.length > 0) {\n        return RangeSet.of(buildNodeDecorations(transaction.state, options))\n      }\n\n      const updatedRangeSet = rangeSet.map(transaction.changes)\n\n      if (transaction.docChanged) {\n        // Only process the ranges that are affected by this change.\n        if (options.optimize) {\n          return RangeSet.of(buildOptimizedNodeDecorations(updatedRangeSet, transaction, options))\n        }\n\n        return RangeSet.of(buildNodeDecorations(transaction.state, options))\n      }\n\n      // No need to redecorate. Instead, just map the decorations through the transaction changes.\n      return updatedRangeSet\n    },\n    provide(field) {\n      // Provide the extension to the editor.\n      return EditorView.decorations.from(field)\n    },\n  })\n}\n","import { syntaxTree } from '@codemirror/language'\nimport { StateField } from '@codemirror/state'\nimport type { EditorState, Extension, Range } from '@codemirror/state'\nimport { Decoration, EditorView, ViewPlugin } from '@codemirror/view'\nimport type { DecorationSet } from '@codemirror/view'\nimport type { SyntaxNodeRef } from '@lezer/common'\nimport { buildWidget } from '/lib/codemirror-kit'\n\nconst tabSize = 2\n\nconst spacerWidget = () => {\n  return buildWidget({\n    toDOM: () => {\n      const spacer = document.createElement('span')\n\n      spacer.className = 'ink-mde-indent'\n      spacer.style.width = `2rem`\n      spacer.style.textDecoration = 'none'\n      spacer.style.display = 'inline-flex'\n\n      const spacerLine = document.createElement('span')\n\n      spacerLine.className = 'ink-mde-indent-marker'\n      spacerLine.innerHTML = '&nbsp;'\n\n      spacer.appendChild(spacerLine)\n\n      return spacer\n    },\n  })\n}\n\nconst createWrapper = () => {\n  const wrapper = document.createElement('label')\n\n  wrapper.setAttribute('aria-hidden', 'true')\n  wrapper.setAttribute('tabindex', '-1')\n  wrapper.className = 'ink-mde-list-marker'\n  wrapper.style.minWidth = '2rem'\n\n  return wrapper\n}\n\nconst taskWidget = (isChecked: boolean) => buildWidget({\n  eq: (other) => {\n    return other.isChecked === isChecked\n  },\n  ignoreEvent: () => false,\n  isChecked,\n  toDOM: () => {\n    const wrapper = createWrapper()\n    const input = document.createElement('input')\n\n    input.setAttribute('aria-hidden', 'true')\n    input.setAttribute('tabindex', '-1')\n    input.className = 'ink-mde-task-marker'\n    input.type = 'checkbox'\n    input.checked = isChecked\n\n    wrapper.classList.add('ink-mde-task')\n\n    wrapper.appendChild(input)\n\n    return wrapper\n  },\n})\n\nconst dotWidget = () => {\n  return buildWidget({\n    toDOM: () => {\n      const wrapper = createWrapper()\n\n      wrapper.setAttribute('inert', 'true')\n      wrapper.innerHTML = '&bull;'\n\n      return wrapper\n    },\n  })\n}\n\nconst numberWidget = (marker: string) => {\n  return buildWidget({\n    toDOM: () => {\n      const wrapper = createWrapper()\n      const content = document.createElement('span')\n\n      wrapper.setAttribute('inert', 'true')\n\n      wrapper.appendChild(content)\n\n      content.setAttribute('aria-hidden', 'true')\n      content.setAttribute('tabindex', '-1')\n      content.className = 'ink-mde-number-marker'\n      content.innerHTML = `${marker}`\n\n      return wrapper\n    },\n  })\n}\n\nconst getVals = (state: EditorState, { from, to, type }: SyntaxNodeRef) => {\n  // Todo: Determine whether to skip blockquote or not.\n  if (type.name === 'Blockquote') {\n    return false\n  }\n\n  if (type.name !== 'ListMark') {\n    return\n  }\n\n  const line = state.doc.lineAt(from)\n  const lineStart = line.from\n  const marker = state.sliceDoc(from, to)\n  const markerStart = from\n  const markerEnd = to\n  const markerHasTrailingSpace = state.sliceDoc(markerEnd, markerEnd + 1) === ' '\n  const indentation = markerStart - lineStart\n\n  if (!markerHasTrailingSpace) {\n    return\n  }\n\n  const indentLevel = Math.floor(indentation / tabSize)\n  const spacerDecorations = <Range<Decoration>[]>[]\n\n  for (const index of Array(indentLevel).keys()) {\n    const from = lineStart + (index * tabSize)\n    const to = from + tabSize\n\n    const spacerDec = Decoration.replace({ widget: spacerWidget() }).range(from, to)\n\n    spacerDecorations.push(spacerDec)\n  }\n\n  return {\n    indentLevel,\n    indentation,\n    lineStart,\n    marker,\n    markerEnd,\n    markerStart,\n    spacerDecorations,\n  }\n}\n\nconst bulletLists = (): Extension => {\n  const decorate = (state: EditorState): [DecorationSet, DecorationSet] => {\n    const atomicRanges = <Range<Decoration>[]>[]\n    const decorationRanges = <Range<Decoration>[]>[]\n\n    syntaxTree(state).iterate({\n      enter: (node) => {\n        const result = getVals(state, node)\n\n        if (!result) {\n          return result\n        }\n\n        const { indentLevel, lineStart, marker, markerEnd, markerStart, spacerDecorations } = result\n\n        if (!['-', '*'].includes(marker)) {\n          return\n        }\n\n        const lineDec = Decoration.line({\n          attributes: {\n            class: 'ink-mde-list ink-mde-bullet-list',\n            style: `--indent-level: ${indentLevel}`,\n          },\n        }).range(lineStart)\n\n        decorationRanges.push(lineDec)\n        decorationRanges.push(...spacerDecorations)\n        atomicRanges.push(...spacerDecorations)\n\n        const textStart = markerEnd + 1\n        const dotDec = Decoration.replace({\n          widget: dotWidget(),\n        }).range(markerStart, textStart)\n\n        decorationRanges.push(dotDec)\n        atomicRanges.push(dotDec)\n      },\n    })\n\n    return [Decoration.set(decorationRanges, true), Decoration.set(atomicRanges, true)]\n  }\n\n  const stateField = StateField.define<[DecorationSet, DecorationSet]>({\n    create(state) {\n      return decorate(state)\n    },\n    update(_references, { state }) {\n      return decorate(state)\n    },\n    provide(field) {\n      const result = [\n        EditorView.decorations.of((view) => {\n          const [decorationRanges, _atomicRanges] = view.state.field(field)\n\n          return decorationRanges\n        }),\n        EditorView.atomicRanges.of((view) => {\n          const [_decorationRanges, atomicRanges] = view.state.field(field)\n\n          return atomicRanges\n        }),\n      ]\n\n      return result\n    },\n  })\n\n  return [\n    stateField,\n  ]\n}\n\nconst numberLists = (): Extension => {\n  const decorate = (state: EditorState): [DecorationSet, DecorationSet] => {\n    const atomicRanges = <Range<Decoration>[]>[]\n    const decorationRanges = <Range<Decoration>[]>[]\n\n    syntaxTree(state).iterate({\n      enter: (node) => {\n        const result = getVals(state, node)\n\n        if (!result) {\n          return result\n        }\n\n        const { indentLevel, lineStart, marker, markerEnd, markerStart, spacerDecorations } = result\n\n        if (['-', '*'].includes(marker)) {\n          return\n        }\n\n        const lineDec = Decoration.line({\n          attributes: {\n            class: 'ink-mde-list ink-mde-number-list',\n            style: `--indent-level: ${indentLevel}`,\n          },\n        }).range(lineStart)\n\n        decorationRanges.push(lineDec)\n        decorationRanges.push(...spacerDecorations)\n        atomicRanges.push(...spacerDecorations)\n\n        const textStart = markerEnd + 1\n        const dotDec = Decoration.replace({\n          widget: numberWidget(marker),\n        }).range(markerStart, textStart)\n\n        decorationRanges.push(dotDec)\n        atomicRanges.push(dotDec)\n      },\n    })\n\n    return [Decoration.set(decorationRanges, true), Decoration.set(atomicRanges, true)]\n  }\n\n  const stateField = StateField.define<[DecorationSet, DecorationSet]>({\n    create(state) {\n      return decorate(state)\n    },\n    update(_references, { state }) {\n      return decorate(state)\n    },\n    provide(field) {\n      const result = [\n        EditorView.decorations.of((view) => {\n          const [decorationRanges, _atomicRanges] = view.state.field(field)\n\n          return decorationRanges\n        }),\n        EditorView.atomicRanges.of((view) => {\n          const [_decorationRanges, atomicRanges] = view.state.field(field)\n\n          return atomicRanges\n        }),\n      ]\n\n      return result\n    },\n  })\n\n  return [\n    stateField,\n  ]\n}\n\nconst taskLists = (): Extension => {\n  const decorate = (state: EditorState): [DecorationSet, DecorationSet] => {\n    const atomicRanges = <Range<Decoration>[]>[]\n    const decorationRanges = <Range<Decoration>[]>[]\n\n    syntaxTree(state).iterate({\n      enter: (node) => {\n        const result = getVals(state, node)\n\n        if (!result) {\n          return result\n        }\n\n        const { indentLevel, lineStart, marker, markerEnd, markerStart, spacerDecorations } = result\n\n        if (!['-', '*'].includes(marker)) {\n          return\n        }\n\n        const taskStart = markerEnd + 1\n        const taskEnd = taskStart + 3\n        const task = state.sliceDoc(taskStart, taskEnd)\n\n        if (!['[ ]', '[x]'].includes(task)) {\n          return\n        }\n\n        const textStart = taskEnd + 1\n        const taskHasTrailingSpace = state.sliceDoc(taskEnd, textStart) === ' '\n\n        if (!taskHasTrailingSpace) {\n          return\n        }\n\n        const isChecked = task === '[x]'\n\n        const lineDec = Decoration.line({\n          attributes: {\n            class: `ink-mde-list ink-mde-task-list ${isChecked ? 'ink-mde-task-checked' : 'ink-mde-task-unchecked'}`,\n            style: `--indent-level: ${indentLevel}`,\n          },\n        }).range(lineStart)\n\n        decorationRanges.push(lineDec)\n        decorationRanges.push(...spacerDecorations)\n        atomicRanges.push(...spacerDecorations)\n\n        const taskDec = Decoration.replace({\n          widget: taskWidget(isChecked),\n        }).range(markerStart, textStart)\n\n        decorationRanges.push(taskDec)\n        atomicRanges.push(taskDec)\n      },\n    })\n\n    return [Decoration.set(decorationRanges, true), Decoration.set(atomicRanges, true)]\n  }\n\n  const viewPlugin = ViewPlugin.define(() => ({}), {\n    eventHandlers: {\n      mousedown: (event, view) => {\n        const target = event.target as HTMLElement\n        const realTarget = target.closest('.ink-mde-list-marker')?.querySelector('.ink-mde-task-marker')\n\n        if (realTarget) {\n          const position = view.posAtDOM(realTarget)\n          const from = position - 4\n          const to = position - 1\n          const before = view.state.sliceDoc(from, to)\n\n          if (before === '[ ]') {\n            view.dispatch({\n              changes: {\n                from,\n                to,\n                insert: '[x]',\n              },\n            })\n          }\n\n          if (before === '[x]') {\n            view.dispatch({\n              changes: {\n                from,\n                to,\n                insert: '[ ]',\n              },\n            })\n          }\n\n          return true\n        }\n      },\n    },\n  })\n\n  const stateField = StateField.define<[DecorationSet, DecorationSet]>({\n    create(state) {\n      return decorate(state)\n    },\n    update(_references, { state }) {\n      return decorate(state)\n    },\n    provide(field) {\n      const result = [\n        EditorView.decorations.of((view) => {\n          const [decorationRanges, _atomicRanges] = view.state.field(field)\n\n          return decorationRanges\n        }),\n        EditorView.atomicRanges.of((view) => {\n          const [_decorationRanges, atomicRanges] = view.state.field(field)\n\n          return atomicRanges\n        }),\n      ]\n\n      return result\n    },\n  })\n\n  return [\n    viewPlugin,\n    stateField,\n  ]\n}\n\nexport const lists = (config: { task: boolean, bullet: boolean, number: boolean }): Extension => {\n  return [\n    config.task ? taskLists() : [],\n    config.bullet ? bulletLists() : [],\n    config.number ? numberLists() : [],\n    EditorView.theme({\n      ':where(.ink-mde-indent)': {\n        display: 'inline-flex',\n        justifyContent: 'center',\n      },\n      ':where(.ink-mde-indent-marker)': {\n        borderLeft: '1px solid var(--ink-internal-syntax-processing-instruction-color)',\n        bottom: '0',\n        overflow: 'hidden',\n        position: 'absolute',\n        top: '0',\n        width: '0',\n      },\n      ':where(.ink-mde-list)': {\n        paddingLeft: 'calc(var(--indent-level) * 2rem + 2rem) !important',\n        position: 'relative',\n        textIndent: 'calc((var(--indent-level) * 2rem + 2rem) * -1)',\n      },\n      ':where(.ink-mde-list *)': {\n        textIndent: '0',\n      },\n      ':where(.ink-mde-list-marker)': {\n        alignItems: 'center',\n        color: 'var(--ink-internal-syntax-processing-instruction-color)',\n        display: 'inline-flex',\n        justifyContent: 'center',\n        minWidth: '2rem',\n      },\n      ':where(.ink-mde-task-marker)': {\n        cursor: 'pointer',\n        margin: '0',\n        scale: '1.2',\n        transformOrigin: 'center center',\n      },\n      ':where(.ink-mde-task-list.ink-mde-task-checked)': {\n        textDecoration: 'line-through',\n        textDecorationColor: 'var(--ink-internal-syntax-processing-instruction-color)',\n      },\n    }),\n  ]\n}\n"],"names":["buildWidget","options","eq","other","tabSize","spacerWidget","spacer","spacerLine","createWrapper","wrapper","taskWidget","isChecked","input","dotWidget","numberWidget","marker","content","getVals","state","from","to","type","lineStart","markerStart","markerEnd","markerHasTrailingSpace","indentation","indentLevel","spacerDecorations","index","spacerDec","Decoration","bulletLists","decorate","atomicRanges","decorationRanges","syntaxTree","node","result","lineDec","textStart","dotDec","StateField","_references","field","EditorView","view","_atomicRanges","_decorationRanges","numberLists","taskLists","taskStart","taskEnd","task","taskDec","viewPlugin","ViewPlugin","event","realTarget","position","before","stateField","lists","config"],"mappings":"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"}